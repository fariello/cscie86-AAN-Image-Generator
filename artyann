#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import sys
import svgwrite
from svgwrite import cm, mm, px


class DrawingObject(object):
	CURREN_COUNT = 0
	_ALL = []
	_HASH = {}
	args = Name
	"""
	Generic drawing object base class. Don't use

	"""
	def __init__(self, args, width=10.0, height=10.0, padding = 0.0, x0 = 0.0, y0 = 0.0):
		DrawingObject.CURREN_COUNT += 1
		self.do_num = DrawingObject.CURREN_COUNT
		if self.__class__ != DrawingObject:
			self.__class__.CURRENT_COUNT += 1
			self.num = self.__class__.CURRENT_COUNT
		else:
			self.num = self.do_num
			pass
		self.args = args
		self.x0 = x0
		self.y0 = y0
		self.shorthand = 'do'
		self.width = width
		self.height = height
		DrawingObject._ALL.append(self)
		pass
	def get_y(self): return (self.height / 2.0) + self.y0
	def set_y(self,val): self.y0 = val - (self.height / 2.0)
	y = property(get_y, set_y)

	def get_x(self): return (self.width / 2.0) + self.x0
	def set_x(self,val): self.x0 = val - (self.width / 2.0)
	x = property(get_x, set_x)

	def get_x_min(self): return self.x0
	x_min = property(get_x_min)
	@property
	def y_min(self): return self.y0
	@property
	def x_max(self): return self.x0 + self.width
	@property
	def y_max(self): return self.y0 + self.height

	def get_bounding_box(self):
		return (self.x_min - self.padding,self.y_min - self.padding),(self.x_max + self.padding, self.y_max + self.padding)

	def get_center(self):
		return (self.x,self.y)

	def get_id(self):
		if self._id is None:
			self.id = "%s%04d" %(self.ID_PREFIX,self.get_num)
		return self._id
	def debug(self,msg):
		print(f"self.args = '{self.args}'")
		if self.args.debug:
			print(f"[DEBUG] {msg}")
			pass
		pass
	pass

class NodeDecoration(object):
	def __init__(self, width=10.0, height=10.0, padding = 0.0, x0 = 0.0, y0 = 0.0, style = "fill:none;stroke:black;stroke-width:0.5;alpha=0.5"):
		if arrowhead_nook_depth is None:
			arrowhead_nook_depth = arrowhead_thickness
			pass
		self.x_0 = 0
		self.x_1 = arrowhead_thickness
		self.x_2 = arrowhead_nook_depth
		self.x_3 = width / 2.0
		self.x_4 = width - arrowhead_nook_depth
		self.x_5 = width - arrowhead_thickness
		self.x_6 = width
		self.y_0 = 0
		self.y_2 = height / 2.0
		self.y_1 = self.y_2 - (arrowbody_height / 2.0)
		self.y_3 = self.y_2 + (arrowbody_height / 2.0)
		self.y_4 = height
		self.width = width
		self.height = height
		self.style = style
		self.scale = 1.0
		pass


	def set_arrowhead_parameters(self, breadth = 0.5, length = 0.25, nook_offset = None):
				   """
arrowhead_length─────────────┐		line_length
						  ┌──┴──┐		 │
						  ┌──────────────┴────────────────┐
						  ┆		┆						  ┆
				  ┌┄┄┄┄┄┄┄┆┄┄┄┄┄•					•┄┄┄┄┄┆┄┄┄┄┄y_0
				  │		  ┆	   ╱│					│╲	  ┆
				  │		  ┆	  ╱ │					│ ╲	  ┆
				  │		  ┆	 ╱	│					│  ╲  ┆
				  │	 ┌┄┄┄┄┆┄╱	└───────────────────┘	╲┄┆┄┄┄┄┄y_1
				  │	 │	  ┆╱							 ╲┆
arrowhead_width───┤ ┌┤	  •								  •┄┄┄┄┄y_2
				  │ ││	  ┆╲							 ╱┆
				  │ │└┄┄┄┄┆┄╲	┌───────────────────┐	╱┄┆┄┄┄┄┄y_3
				  │ │	  ┆	 ╲	│↖		  ┆		   ↗│  ╱  ┆
				  │ │	  ┆	  ╲ │ x_2	  ┆		x_4 │ ╱	  ┆
				  │ │	  ┆	   ╲│		  ┆			│╱	  ┆
				  └┄│┄┄┄┄┄┆┄┄┄┄┄•		  ┆			•┄┄┄┄┄┆┄┄┄┄┄y_4
					│	  ┆		┆		  ┆			┆	  ┆
   line_width ──────┘	  ┆		┆		  ┆			┆	  ┆
						 x_0   x_1		 x_3	   x_5	 x_6
		"""


	def get_double_arrow(self, drw, scale = 1.0):
		d=['M', self.x_0 * self.scale, self.y_2 * self.scale, # h
		   'L', self.x_1 * self.scale, self.y_4 * self.scale, # n
		   'L', self.x_2 * self.scale, self.y_3 * self.scale, # m
		   'L', self.x_4 * self.scale, self.y_3 * self.scale, # f
		   'L', self.x_5 * self.scale, self.y_4 * self.scale, # e
		   'L', self.x_6 * self.scale, self.y_2 * self.scale, # d
		   'L', self.x_5 * self.scale, self.y_0 * self.scale, # c
		   'L', self.x_4 * self.scale, self.y_1 * self.scale, # b
		   'L', self.x_2 * self.scale, self.y_1 * self.scale, # j
		   'L', self.x_1 * self.scale, self.y_0 * self.scale, # i
		   'Z']
		#print(d)
		return drw.path(d=d,id="double-arrow",style=self.style)

	def get_right_arrow(self, drw, scale = 1.0):
		d=['M', self.x_0 * self.scale, self.y_2 * self.scale, # g
		   'L', self.x_4 * self.scale, self.y_3 * self.scale, # f
		   'L', self.x_5 * self.scale, self.y_4 * self.scale, # e
		   'L', self.x_6 * self.scale, self.y_2 * self.scale, # d
		   'L', self.x_5 * self.scale, self.y_0 * self.scale, # c
		   'L', self.x_4 * self.scale, self.y_1 * self.scale, # b
		   'L', self.x_0 * self.scale, self.y_1 * self.scale, # a
		   'Z']
		#print(d)
		return drw.path(d=d,id="right-arrow",style=self.style)

	def get_left_arrow(self, drw, scale = 1.0):
		d=['M', self.x_0 * self.scale, self.y_2 * self.scale, # h
		   'L', self.x_1 * self.scale, self.y_4 * self.scale, # n
		   'L', self.x_2 * self.scale, self.y_3 * self.scale, # m
		   'L', self.x_6 * self.scale, self.y_3 * self.scale, # l
		   'L', self.x_6 * self.scale, self.y_1 * self.scale, # k
		   'L', self.x_2 * self.scale, self.y_1 * self.scale, # j
		   'L', self.x_1 * self.scale, self.y_0 * self.scale, # i
		   'Z']
		#print(d)
		return drw.path(d=d,id="double-arrow",style=self.style)

	def get_grid(self,drw, scale = 1.0):
		g = drw.g()
		# Horizontals
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_0 * self.scale),
			end=(self.x_6 * self.scale, self.y_0 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_1 * self.scale),
			end=(self.x_6 * self.scale, self.y_1 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_2 * self.scale),
			end=(self.x_6 * self.scale, self.y_2 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_3 * self.scale),
			end=(self.x_6 * self.scale, self.y_3 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_4 * self.scale),
			end=(self.x_6 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		# Verticals
		g.add(drw.line(
			start=(self.x_0 * self.scale, self.y_0 * self.scale),
			end=(self.x_0 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_1 * self.scale, self.y_0 * self.scale),
			end=(self.x_1 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_2 * self.scale, self.y_0 * self.scale),
			end=(self.x_2 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_3 * self.scale, self.y_0 * self.scale),
			end=(self.x_3 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_4 * self.scale, self.y_0 * self.scale),
			end=(self.x_4 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_5 * self.scale, self.y_0 * self.scale),
			end=(self.x_5 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		g.add(drw.line(
			start=(self.x_6 * self.scale, self.y_0 * self.scale),
			end=(self.x_6 * self.scale, self.y_4 * self.scale),
			style="stroke:#FF0000;stroke-width:0.1;alpha=0.5")
		)
		return g
	pass

class Node(DrawingObject):
	"""
	Base class for all network graph nodes.

	It's not intended to be instantiated directly as written.

	Also note that it is not "thread safe".
	"""
	_num = None
	_name = None
	_description = None
	_decoration = None
	_fill_color = None
	_fill_stroke = None
	_stroke_color = None
	_stroke_alpha = None
	_is_hidden = False
	_is_input = False
	_is_output = False
	_link_self = False
	_shape = 'circle'
	_shorthand = None

	CURRENT_COUNT = 0
	NOVAL = '-38294.127 No VAL'


	NODE_COLOR = '#FFFFFF'
	INPUT_COLOR = '#FFCC00'
	HIDDEN_COLOR = '#CCCC00'
	OUTPUT_COLOR = '#66CC00'
	DEFAULT_COLOR = '#CCFF00'
	SHORTHAND_DICT = {}

	def __init__(self,args):
		super().__init__(args)
		Node.CURRENT_COUNT += 1
		self._num = Node.CURRENT_COUNT
		pass

	def get_drawer(self):
		if 'circle' == self.get_shape():
			return svgwrite.Drawing.circle
		if 'square' == self.get_shape():
			return svgwrite.Drawing.rect
		raise ValueError("Don't know how to get a drawer for shapte '%s'" %(self.get_shape()))

	def get_num(self): self._num

	def get_is_square(self): return 'square' == self.get_shape()
	def get_is_circle(self): return 'cicle' == self.get_shape()

	def get_name(self): return self._name
	def set_name(self,val): self._name = val; return self

	def get_description(self): return self._description
	def set_description(self,val): self._description = val; return self

	def get_decoration(self): return self._decoration
	def set_decoration(self,val): self._decoration = val; return self

	def get_fill_color(self): return self._fill_color
	def set_fill_color(self,val): self._fill_color = val; return self

	def get_fill_stroke(self): return self._fill_stroke
	def set_fill_stroke(self,val): self._fill_stroke = val; return self

	def get_stroke_color(self): return self._stroke_color
	def set_stroke_color(self,val): self._stroke_color = val; return self

	def get_stroke_alpha(self): return self._stroke_alpha
	def set_stroke_alpha(self,val): self._stroke_alpha = val; return self

	def get_is_hidden(self): return self._is_hidden
	def set_is_hidden(self,val): self._is_hidden = val; return self

	def get_is_input(self): return self._is_input
	def set_is_input(self,val): self._is_input = val; return self

	def get_is_output(self): return self._is_output
	def set_is_output(self,val): self._is_output = val; return self

	def get_link_self(self): return self._link_self
	def set_link_self(self,val): self._link_self = val; return self

	def get_shape(self): return self._shape
	def set_shape(self,val): self._shape = val; return self

	def get_shorthand(self): return self._shorthand
	def set_shorthand(self,val): self._shorthand = val; return self

	def get_svg_grp(self,canvas,num=None):
		self._grp_id = "g%04d" %self.get_num()
		self._grp = drawing_obj.g(id=self._grp_id)
		if self.get_is_square():
			# Put square centered on x,y
			q = (3.0/4.0)*self.radius_scale
			node = drawing_obj.rect((self.x-q,self.y-q),(q*2, q*2),fill=self.get_fill_css())
		elif self.get_is_circle():
			node = drawing_obj.circle(center=(self.x,self.y),r=self.radius_scale,fill=self.get_fill_css())
			pass
		else:
			raise ValueError("Cannot get_svg_grp on shape of type '%s'" %(self.get_shape()))
		g.add(node)
		if Node.SUBTYPE_INPUT == self.subtype:
			symbol = drawing_obj.circle(center=(self.x,self.y),r=self.radius_scale/2.0,fill='none',stroke=self.fg,stroke_width=2.0)
			g.add(symbol)
			pass
		elif Node.SUBTYPE_NORMAL == self.subtype:
			symbol = drawing_obj.rect((self.x - self.radius_scale/4.0 ,self.y - self.radius_scale/4.0),(self.radius_scale/2.0,self.radius_scale/2.0),fill='none',
							  stroke=self.fg,stroke_width=2.0)
			g.add(symbol)
			pass
		elif Node.SUBTYPE_NOISY == self.subtype:
			q = self.radius_scale/4.0
			x = self.x-(q*2)
			x_max = self.x+(q*3)
			y1 = self.y+q
			y2 = self.y-q
			y = y1
			d=["M"]
			while x < x_max:
				d.append(x)
				d.append(y)
				if y1 == y:
					y = y2
				else:
					y = y1
					pass
				x += q
				pass
			symbol = drawing_obj.path(tuple(d),fill='none',stroke=self.fg,stroke_width=2.0)
			g.add(symbol)
			pass
		if num is not None:
			q = (3.0/4.0)*self.radius_scale
			x = self.x + q
			y = self.y + q + (self.radius_scale/4.0)
			text = drawing_obj.text("%s" %(num),insert=(x,y),
							style="font-size:6px;font-family:Arial;stroke:white;stroke-width:1;fill:white",
						   )
			g.add(text)
			text = drawing_obj.text("%s" %(num),insert=(x,y),
							style="font-size:6px;font-family:Arial;stroke:black;stroke-width:0.25;fill:black",
						   )
			g.add(text)
			pass
		return g
		pass

	def center(self,x,y):
		self.x = x
		self.y = y
	pass

def set_and_ret_self(self,key,val):
	setattr(self,key,val)
	return self

def _NewNodeClass(name,description,decoration,fill_color,fill_alpha,stroke_color,stroke_alpha,is_output,is_input,link_self,shape,shorthand,extras={}):
	if shorthand in Node.SHORTHAND_DICT:
		raise ValueError("Cannot define two classes with shorthand '%s'" %(shorthand))
	class_name = ''.join(name.split(' '))
	base_dict = {
		'_name': name,
		'_desc': description,
		'_decoration': decoration,
		'_fill_color': fill_color,
		'_fill_color': fill_alpha,
		'_stroke_color': stroke_color,
		'_strole_alpha': stroke_alpha,
		'_is_hidden': not (is_output and is_input),
		'_is_input': is_input,
		'_is_output': is_output,
		'_link_self': link_self,
		'_shape': shape,
		'_shorthand': shorthand,
		}
	new_class = type(class_name,(Node,),base_dict)
	for var_name, init_val in base_dict.items():
		setattr(new_class,var_name,init_val)
		pass
	for name, val in extras.items():
		setattr(new_class,name,val)
		pass
	Node.SHORTHAND_DICT[shorthand] = new_class
	globals()[class_name]=new_class
	pass

_NewNodeClass(
	name = 'Circle Node',
	description = 'A generic circle node.',
	shorthand = 'c',
	decoration = None,
	fill_color = None,
	fill_alpha = 0.0,
	stroke_color = 'black',
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'circle',
	)

# import inspect
# import types
# for key in dir(CircleNode):
#	  attr = getattr(CircleNode,key)
#	  if (isinstance(attr,types.FunctionType)):
#		  attr = inspect.getsource(attr).strip()
#		  pass
#	  print("[DEBUG] %s=%s" %(key,attr))
#	  pass

_NewNodeClass(
	name = 'Input Data',
	description = 'A "node" representing an input feature rather than a artificial neural node.',
	shorthand = 'i',
	decoration = 'right-arrow',
	fill_color = Node.INPUT_COLOR,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Input Node',
	description = 'An artificial neural node providing input (often with an identity function meaning input = output).',
	shorthand = 'I',
	decoration = 'right-arrow',
	fill_color = Node.INPUT_COLOR,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Backfed Node',
	description = 'An artificial neural node with feedback (it\'s output is fed back to it as input).',
	shorthand = 'B',
	decoration = 'double-arrow',
	stroke_color = None,
	fill_color = Node.NODE_COLOR,
	fill_alpha = 1.0,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Noisy Node',
	description = 'An artificial neural node that adds noise to the data.',
	shorthand = 'N',
	fill_color = Node.NODE_COLOR,
	decoration = None,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Output Node',
	description = 'An artificial neural node that provides the output from the network.',
	shorthand = 'O',
	fill_color = Node.OUTPUT_COLOR,
	decoration = None,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Hidden Node',
	description = 'An normal artificial neural node that recieves input from nodes and outputs to nodes (as opposed to recieving raw data/features or outputting to something outside the network.',
	shorthand = 'H',
	fill_color = Node.OUTPUT_COLOR,
	decoration = None,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Matched Output Node',
	description = 'An artificial neural node that recieves input from nodes and outputs to nodes (as opposed to recieving raw data/features or outputting to something outside the network.',
	shorthand = 'M',
	fill_color = Node.OUTPUT_COLOR,
	decoration = None,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)
_NewNodeClass(
	name = 'Probabilistic Hidden Node',
	description = 'An artificial neural hidden node that applies a radial bias function to the difference between the test case and the node\s mean.',
	shorthand = 'P',
	fill_color = Node.OUTPUT_COLOR,
	decoration = None,
	fill_alpha = 1.0,
	stroke_color = None,
	stroke_alpha = 1.0,
	is_output = False,
	is_input = False,
	link_self = False,
	shape = 'square',
)

class MatchOutputNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'output','features','Match Output Node')

class HiddenNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'hidden','normal','Hidden Node')

class ProbabilisticHiddenNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'hidden','normal','Probabilistic Hidden Node')

class SpikingHiddenNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'hidden','features','Spiking Hidden Node')

class RecurrentNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'other1','normal','Recurrent Node')

class MemoryNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'other1','normal','Memory Node')

class DifferentMemoryNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'other1','features','Different Memory Node')

class KernelNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'other2','features','Kernel Node')

class ConvolutionalNode(Node):
	def __init__(self,args,x=0,y=0): return super().__init__(args,x,y,'other2','normal','Convolutional or Pool Node')

class Layer(DrawingObject):
	ID_PREFIX = 'L'
	CURRENT_COUNT = 0
	"""
	A drawing object which containes a "layer" of a network
	"""
	def __init__(self,args, x=None, y=None, network = None, nodes = []):
		super().__init__(args,x,y)
		self.nodes = nodes
		self.network = network
		pass

	def add_node(self, node):
		self.nodes.append(node)
		return self

	def get_nodes(self):
		return self.nodes

class Network(DrawingObject):
	ID_PREFIX = 'W'
	CURRENT_COUNT = 0
	diameter_scale = 20.0
	radius_scale = 10.0

	def __init__(self,args,name=None,id=None,defstr=None):
		super().__init__(args)
		self.id = id
		self.name = name
		self.current_layer = None
		self.layers = []
		if defstr is not None:
			self.from_string(defstr)
		pass

	def new_layer(self):
		self.current_layer = Layer(network = self)
		self.layers.append(self.current_layer)
		return self.current_layer

	def add_node(self,node):
		if self.current_layer is None:
			self.add_layer()
			pass
		self.current_layer.add_node(node)
		return self

	def largest_layer_size(self):
		largest_layer_size = 0
		for layer in self.layers:
			if len(layer) > largest_layer_size:
				largest_layer_size = len(layer)
				pass
			pass
		return largest_layer_size

	def layer_height(self,layer_size):
		if 0 == layer_size:
			return 0.0
		if 1 == layer_size:
			return self.diameter_scale
		return ((layer_size * 2.0) - 1.0 ) * self.diameter_scale

	def from_string(self,defstr):
		n = 0
		self.layers = []
		self.new_layer()
		for s in defstr:
			n += 1
			if 'i' == s:
				self.add_node(InputData(self.args))
			elif 'b' == s:
				self.add_node(BackfedInput(self.args))
			elif 'B' == s:
				self.add_node(BackfedNode(self.args))
			elif 'n' == s:
				self.add_node(NoisyInput(self.args))
			elif 'N' == s:
				self.add_node(NoisyNode(self.args))
			elif 'o' == s:
				self.add_node(OutputNode(self.args))
			elif 'M' == s:
				self.add_node(MatchOutputNode(self.args))
			elif 'h' == s:
				self.add_node(HiddenNode(self.args))
			elif 'p' == s:
				self.add_node(ProbabilisticHiddenNode(self.args))
			elif 's' == s:
				self.add_node(SpikingHiddenNode(self.args))
			elif 'r' == s:
				self.add_node(RecurrentNode(self.args))
			elif 'm' == s:
				self.add_node(MemoryNode(self.args))
			elif 'd' == s:
				self.add_node(DifferentMemoryNode(self.args))
			elif 'k' == s:
				self.add_node(KernelNode(self.args))
			elif 'c' == s:
				self.add_node(ConvolutionalNode(self.args))
			elif '|' == s:
				self.new_layer()
			else:
				raise ValueError("Don't know what '%s' is." %(s))
				pass
			pass
		return self

	def draw(self,drawing_obj=None,number_nodes=False):
		largest_layer_size = self.largest_layer_size()
		max_layer_height = self.layer_height(largest_layer_size)
		net_x_middle = max_layer_height / 2.0
		width = (len(self.layers)+1) * self.diameter_scale * 2.0
		height = max_layer_height + self.diameter_scale
		bottom = height
		left = self.diameter_scale
		self.filename = "ANN-%s.svg" %(self.name)
		if drawing_obj is None:
			drawing_obj = svgwrite.Drawing(
				filename=self.filename,
				debug=True,
				size=(width,height),
				style="font-size:6px;font-family:Arial;stroke:#999999;stroke-width:0.25;fill:none",
			)
			pass
		self.g = drawing_obj.g(id=self.id)
		#self.g.add(drawing_obj.title(self.name))
		layer_num = -1
		svg_layers = []
		svg_lines = []
		n = 0
		self.debug(self.layers)
		for layer in self.layers:
			layer_num += 1
			layer_size = len(layer)
			n += layer_size
			layer_height = self.layer_height(layer_size)
			layer_bottom = bottom - self.diameter_scale - net_x_middle + (layer_height / 2.0)
			layer_group = drawing_obj.g(id="%s_l%d" %(self.id, layer_num))
			node_count = -1
			x = left + (layer_num * 2 * self.diameter_scale)
			for node in layer:
				node_count += 1
				y = layer_bottom - (node_count * 2 * self.diameter_scale)
				node.center(x,y)
				#print("%s (%s,%s)" %(node.name, node.x, node.y))
				if number_nodes:
					svg_node = node.get(drawing_obj, n)
				else:
					svg_node = node.get(drawing_obj)
					pass
				#print(svg_node.tostring())
				layer_group.add(svg_node)
				n -= 1
				pass
			svg_layers.append(layer_group)
			n += layer_size
			pass
		cur_idx = 1
		while cur_idx < 20 and cur_idx < len(self.layers):
			prev_idx = cur_idx - 1
			for start_node in self.layers[prev_idx]:
				start_x = start_node.x
				start_y = start_node.y
				for end_node in self.layers[cur_idx]:
					end_x = end_node.x
					end_y = end_node.y
					line = drawing_obj.line(start=(start_x,start_y),end=(end_x,end_y),stroke='#333333',
									stroke_width=2.0, stroke_opacity=0.66)
					#print(line.tostring())
					self.g.add(line)
					pass
				pass
			cur_idx += 1
			pass
		for svg_layer in svg_layers:
			self.g.add(svg_layer)
		drawing_obj.add(self.g)
		print("Saving %s" %(self.filename))
		drawing_obj.save()
		pass
	pass


def test_diagrams(args):
	net = Network(name="Test",id='test',defstr="iii|bbb|nnn|hhh|ppp|sss|rrr|mmm|ddd|kkk|ccc|MMM|ooo").draw()
	net = Network(name="Legend",id='legend',defstr="oMckdmrsphnbi").draw()
	net = Network(name="Perceptron",id='P',defstr="iiii|o").draw()
	net = Network(name="Feed Forward",id='FF',defstr="ii|hh|o").draw()
	net = Network(name="Radial Basis Network",id='RBN',defstr="ii|hh|o").draw()
	net = Network(name="Deep Feed Forward",id='DFF',defstr="iii|hhhh|hhhh|oo").draw()
	net = Network(name="Deep Feed Forward 2",id='DFF',defstr="iiiiiiiii|hhhhhh|hhhhhh|hhhhhh|hhhhhh|hhhh|oo").draw()
	net = Network(name="Recurrent Neural Network",id='RNN',defstr="iii|rrr|rrr|ooo").draw()
	net = Network(name="Recurrent Neural Network 2",id='RNN',defstr="iiiii|hhhhh|rrrrr|rrrrr|rrrrr|rrrrr|hhhhh|oo").draw()
	net = Network(name="Long-Short Term Memory Network",id='LSTM',defstr="iii|mmm|mmm|ooo").draw()
	net = Network(name="Gated Recurrent Unit Network",id='GRU',defstr="iii|ddd|ddd|ooo").draw()
	net = Network(name="Deep Convolutional Network",id='DCN',defstr="iiiii|kkkkk|cccc|ccc|cc|hhhh|hhhh|ooo").draw()
	net = Network(name="Deep Convolutional Network 2",id='DCN',defstr="iiiii|hhhhh|kkkkk|cccc|ccc|cc|hhhh|hhhh|ooo").draw()
	net = Network(name="Convolutional Network",id='CNN',defstr="iiiii|kkkkk|cccc|ccc|cc|o").draw()
	net = Network(name="Deconvolutional Network",id='DN',defstr="ii|ccc|cccc|kkkkk|ooooo").draw()
	net = Network(name="Deconvolutional Network 2",id='DN',defstr="ii|cc|ccc|cccc|kkkkk|ooooo").draw()
	net = Network(name="Deep Convolutional Inverse Graphics Network",id='DCIGN',defstr="iiiii|kkkkk|cccc|ccc|ppp|ccc|cccc|kkkkk|ooooo").draw()
	net = Network(name="Generative Adversarial Network",id='GAN',defstr="bbb|hhh|hhh|MMM|hhh|hhh|MM").draw()
	net = Network(name="Generative Adversarial Network 2",id='GAN',defstr="iii|rrr|hhh|hhh|MMM|hhh|hhh|MM").draw()
	net = Network(name="Liquid State Machine",id='LQM',defstr="iii|ssss|ssss|ssss|oo").draw()
	net = Network(name="Extreme Learning Machine",id='ELM',defstr="iii|hhhh|hhhh|hhhh|oo").draw()
	net = Network(name="Echo State Network",id='ESN',defstr="iii|rrrr|rrrr|rrrr|oo").draw()
	net = Network(name="Autoencoder",id='AE',defstr="iiii|hh|MMMM").draw()
	net = Network(name="Autoencoder 2",id='AE',defstr="iiiiii|hhhh|hhh|hhhh|MMMMMM").draw()
	net = Network(name="Variational Autoencoder",id='VAE',defstr="iiii|pppp|MMMM").draw()
	net = Network(name="Variational Autoencoder 2",id='AE',defstr="iiiiii|pppp|ppp|pppp|MMMMMM").draw()
	net = Network(name="Denoising Autencoder",id='DAE',defstr="nnnn|hhhh|MMMM").draw()
	net = Network(name="Denoising Autencoder 2",id='DAE',defstr="iiiiii|NNNNNN|hhhh|hhh|hhhh|MMMMMM").draw()
	net = Network(name="Sparse Autoencoder",id='SAE',defstr="ii|hhhh|MM").draw()
	net = Network(name="Sparse Autoencoder 2",id='SAE',defstr="iiiii|hhhhh|hhh|hhhhh|MMMMM").draw()
	net = Network(name="Deep Residual Network",id='DSN',defstr="iii|hhh|hhh|hhh|hhh|hhh|hhh|hhh|oo").draw()
	net = Network(name="Kohonen Network",id='KN',defstr="ii|hhh|hhh|hhh").draw()
	net = Network(name="Support Vector Machine",id='SVN',defstr="iii|hhh|hhh|o").draw()
	net = Network(name="Neural Turing Machine",id='NTM',defstr="iii|hh|hh|hhh|mmm|o").draw()
	net = Network(name="Deep Belief Network",id='DBN',defstr="bbbb|pp|hhhh|pp|hhhh|pp|MMMM").draw()
	net = Network(name="Deep Belief Network 2",id='DBN',defstr="iiii|hhhh|pp|hhhh|pp|hhhh|pp|MMMM").draw()
	net = Network(name="Restricted Boltzmann Machine",id='RBM',defstr="bbb|pppp").draw()
	net = Network(name="Restricted Boltzmann Machine 2",id='RBM',defstr="iii|hhh|rrrr").draw()
	#net = Network(name="Boltzmann Machine",id='BM',defstr="iiiiii|hhhhhh|rrrrrrr").draw()
	pass

def main():
	parser = argparse.ArgumentParser(description='A tool for generating quick-and-dirty *art-y* represenations of some types artificial neural networks *ann*s.')
	parser.add_argument('specs', type=str, nargs='*')
	parser.add_argument('--help-specs', default=False, dest='help_specs', help="Provide help with the 'specs' format and content.")
	parser.add_argument('--quiet', '-q', default=0, dest='quiet', action='count',help="Decrease verbosity. Can have multiple.")
	parser.add_argument('--save', '-s', default=None, type=str, dest='save_filename', help="Save to image file. Recommend file names ending in .svg for high quality or .png for other needs.")
	parser.add_argument('--title', default=None, type=str, dest='title', help="Title for the figure.")
	parser.add_argument('--debug', '-d', default=False, action='store_true', dest='debug', help="Turn debugging on.")
	parser.add_argument('--test', default=False, action='store_true', dest='test', help="Create 'test' network diagrams.")
	parser.add_argument('--verbose', '-v', default=0, dest='verbosity', action='count',help="Increase verbosity. Can have multiple.")
	parser.add_argument('--fig-width-in', '-wi', default=None, type=float, dest='fig_width_in',help="Width in inches of the figure. ")
	parser.add_argument('--fig-height-in', '-hi', default=None, type=float, dest='fig_height_in',help="Height in inches of the figure. ")
	parser.add_argument('--fig-width-mm', '-wmm', default=None, type=float, dest='fig_width_mm',help="Width in inches of the figure. ")
	parser.add_argument('--fig-height-mm', '-hmm', default=None, type=float, dest='fig_height_mm',help="Height in inches of the figure. ")

	args = parser.parse_args()
	args.verbosity = 1 + args.verbosity - args.quiet

	DrawingObject.args = args

	if args.test:
		test_diagrams()
		sys.exit(0)

	if len(args.specs) < 1:
		print("No specs provided. Nothing to do.")
		sys.exit(1)
		pass
	for spec in args.specs:
		n = Network()
		n.from_string(spec)
		pass
	pass

if __name__ == "__main__":
	main()
	sys.exit(0)
	pass

sys.exit(1)

# In[7]:
